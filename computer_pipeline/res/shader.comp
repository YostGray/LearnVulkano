#version 460

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
// 本地工作组可以共享Shadered变量 如：shared vec4 mat_shared[8][8];

layout(set = 0, binding = 0) buffer Data {
    uint seed;
    uint size;
    uint frequency;
    uint fbm_time;
} buf;

layout(set = 0, binding = 1, rgba8) uniform writeonly image2D img;

// //from https://www.shadertoy.com/view/ltB3zD
// const float PHI = 1.61803398874989484820459;
// float gold_noise(float seed, vec2 pos)
// {
//     return fract(tan(distance(pos*PHI, pos) * seed)*pos.x);
// }

// vec2 get_random_grade(float seed, vec2 pos)
// {
//     float x = gold_noise(seed,pos);
//     float y = gold_noise(seed + 0.5,pos);
//     vec2 v = vec2(x,y);
//     return v / length(v);
// }

// const int BIT_NOISE1 = 0x85297A4D;
// const int BIT_NOISE2 = 0x68E31DA4;
// const int BIT_NOISE3 = 0x1B56C4E9;
// //从混合坐标生成随机的一个0.0到1024.0数 具有哈希性质
// float rand_value_11(uint seed, int mixed)
// {
//     int mangled = mixed ^ int(seed);
//     mangled *= BIT_NOISE1;
//     mangled ^= mangled >> 8;
//     mangled += BIT_NOISE2;
//     mangled ^= mangled << 8;
//     mangled *= BIT_NOISE3;
//     mangled ^= mangled >> 8;
//     return mod(mangled,1024);
// }

// //从坐标生成随机的一个单位向量 具有哈希性质
// vec2 rand_value_22(uint seed, vec2 pos)
// {
//     int mixed_x = int(pos.x * 0x651A6BE3 - pos.y);
//     int mixed_y = int(pos.x * pos.y + 0x218AE247);

//     float x = rand_value_11(seed,mixed_x);
//     float y = rand_value_11(seed,mixed_y);
//     vec2 v = vec2(x,y) / 1024;
//     return v / length(v);
// }

vec2 rand_value_22(uint seed, vec2 pos)
{
    float x = length(pos) + 58.12 + 79.52 * float(seed);
    float y = length(pos) + 96.53 + 36.95 * float(seed);
    x = fract(sin(x));
    y = fract(sin(y));
    vec2 v = normalize(vec2(x,y));
    return v;
} 

float perline_noise_lerp(float a,float b,float t)
{
    float new_t = 3 * pow(t,2) - 2 * pow(t,3);
    return a + new_t * (b - a);
}

void main() {
    vec2 pos = vec2(gl_GlobalInvocationID.xy);
    uint block_size = buf.size / buf.frequency;

    //p0 p3
    //p1 p2
    vec2 p0 = pos - mod(pos, block_size);
    vec2 p2 = p0 + vec2(block_size, block_size);
    vec2 p1 = vec2(p0.x, p2.y);
    vec2 p3 = vec2(p2.x, p0.y);

    vec2 dir_P0 = (pos - p0) / block_size;
    vec2 dir_P1 = (pos - p1) / block_size;
    vec2 dir_P2 = (pos - p2) / block_size;
    vec2 dir_P3 = (pos - p3) / block_size;

    vec2 grade_P0 = rand_value_22(buf.seed, p0);
    vec2 grade_P1 = rand_value_22(buf.seed, p1);
    vec2 grade_P2 = rand_value_22(buf.seed, p2);
    vec2 grade_P3 = rand_value_22(buf.seed, p3);

    float v0 = dot(grade_P0, dir_P0);
    float v1 = dot(grade_P1, dir_P1);
    float v2 = dot(grade_P2, dir_P2);
    float v3 = dot(grade_P3, dir_P3);

    vec2 t = dir_P0;
    float v = perline_noise_lerp (
        perline_noise_lerp(v0,v3,t.x),
        perline_noise_lerp(v1,v2,t.x),
        t.y
    );
    v = (v + 1.0) / 2.0;
    vec4 to_write = vec4(v, v, v, 1.0);
    // vec4 to_write = vec4((grade_P3 + vec2(1,1)) / 2, 0, 1.0);
    // vec4 to_write = vec4((grade_P0.x + 1)/2, (grade_P0.y + 1)/2, 0, 1.0);
    imageStore(img, ivec2(gl_GlobalInvocationID.xy), to_write);
}